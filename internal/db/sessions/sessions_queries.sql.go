// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: sessions_queries.sql

package sessions

import (
	"context"
	"database/sql"
)

const countSessions = `-- name: CountSessions :one
SELECT COUNT(*) FROM sessions
`

func (q *Queries) CountSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSessionsByUserID = `-- name: CountSessionsByUserID :one
SELECT COUNT(*) FROM sessions WHERE user_id = ?
`

func (q *Queries) CountSessionsByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessionsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMagicToken = `-- name: CreateMagicToken :exec

INSERT INTO magic_tokens (token_hash, email, user_id, expires_at, created_at)
VALUES (?, ?, ?, ?, ?)
`

type CreateMagicTokenParams struct {
	TokenHash string         `json:"token_hash"`
	Email     string         `json:"email"`
	UserID    sql.NullString `json:"user_id"`
	ExpiresAt int64          `json:"expires_at"`
	CreatedAt int64          `json:"created_at"`
}

// Magic tokens operations
func (q *Queries) CreateMagicToken(ctx context.Context, arg CreateMagicTokenParams) error {
	_, err := q.db.ExecContext(ctx, createMagicToken,
		arg.TokenHash,
		arg.Email,
		arg.UserID,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const createOAuthClient = `-- name: CreateOAuthClient :exec

INSERT INTO oauth_clients (client_id, client_secret_hash, client_name, redirect_uris, is_public, token_endpoint_auth_method, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateOAuthClientParams struct {
	ClientID                string         `json:"client_id"`
	ClientSecretHash        sql.NullString `json:"client_secret_hash"`
	ClientName              sql.NullString `json:"client_name"`
	RedirectUris            string         `json:"redirect_uris"`
	IsPublic                int64          `json:"is_public"`
	TokenEndpointAuthMethod sql.NullString `json:"token_endpoint_auth_method"`
	CreatedAt               int64          `json:"created_at"`
}

// OAuth clients operations
func (q *Queries) CreateOAuthClient(ctx context.Context, arg CreateOAuthClientParams) error {
	_, err := q.db.ExecContext(ctx, createOAuthClient,
		arg.ClientID,
		arg.ClientSecretHash,
		arg.ClientName,
		arg.RedirectUris,
		arg.IsPublic,
		arg.TokenEndpointAuthMethod,
		arg.CreatedAt,
	)
	return err
}

const createOAuthCode = `-- name: CreateOAuthCode :exec

INSERT INTO oauth_codes (code_hash, client_id, user_id, redirect_uri, scope, resource, code_challenge, code_challenge_method, expires_at, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOAuthCodeParams struct {
	CodeHash            string         `json:"code_hash"`
	ClientID            string         `json:"client_id"`
	UserID              string         `json:"user_id"`
	RedirectUri         string         `json:"redirect_uri"`
	Scope               sql.NullString `json:"scope"`
	Resource            sql.NullString `json:"resource"`
	CodeChallenge       string         `json:"code_challenge"`
	CodeChallengeMethod sql.NullString `json:"code_challenge_method"`
	ExpiresAt           int64          `json:"expires_at"`
	CreatedAt           int64          `json:"created_at"`
}

// OAuth authorization codes operations
func (q *Queries) CreateOAuthCode(ctx context.Context, arg CreateOAuthCodeParams) error {
	_, err := q.db.ExecContext(ctx, createOAuthCode,
		arg.CodeHash,
		arg.ClientID,
		arg.UserID,
		arg.RedirectUri,
		arg.Scope,
		arg.Resource,
		arg.CodeChallenge,
		arg.CodeChallengeMethod,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const createOAuthToken = `-- name: CreateOAuthToken :exec

INSERT INTO oauth_tokens (access_token_hash, refresh_token_hash, client_id, user_id, scope, resource, expires_at, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOAuthTokenParams struct {
	AccessTokenHash  string         `json:"access_token_hash"`
	RefreshTokenHash sql.NullString `json:"refresh_token_hash"`
	ClientID         string         `json:"client_id"`
	UserID           string         `json:"user_id"`
	Scope            sql.NullString `json:"scope"`
	Resource         sql.NullString `json:"resource"`
	ExpiresAt        int64          `json:"expires_at"`
	CreatedAt        int64          `json:"created_at"`
}

// OAuth tokens operations
func (q *Queries) CreateOAuthToken(ctx context.Context, arg CreateOAuthTokenParams) error {
	_, err := q.db.ExecContext(ctx, createOAuthToken,
		arg.AccessTokenHash,
		arg.RefreshTokenHash,
		arg.ClientID,
		arg.UserID,
		arg.Scope,
		arg.Resource,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const createSession = `-- name: CreateSession :exec


INSERT INTO sessions (session_id, user_id, expires_at, created_at)
VALUES (?, ?, ?, ?)
`

type CreateSessionParams struct {
	SessionID string `json:"session_id"`
	UserID    string `json:"user_id"`
	ExpiresAt int64  `json:"expires_at"`
	CreatedAt int64  `json:"created_at"`
}

// Sessions queries for the shared sessions database
// Sessions CRUD operations
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession,
		arg.SessionID,
		arg.UserID,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const createShortURL = `-- name: CreateShortURL :exec

INSERT INTO short_urls (short_id, full_path, created_at)
VALUES (?, ?, ?)
`

type CreateShortURLParams struct {
	ShortID   string `json:"short_id"`
	FullPath  string `json:"full_path"`
	CreatedAt int64  `json:"created_at"`
}

// Short URL operations
func (q *Queries) CreateShortURL(ctx context.Context, arg CreateShortURLParams) error {
	_, err := q.db.ExecContext(ctx, createShortURL, arg.ShortID, arg.FullPath, arg.CreatedAt)
	return err
}

const createUserKey = `-- name: CreateUserKey :exec

INSERT INTO user_keys (user_id, kek_version, encrypted_dek, created_at)
VALUES (?, ?, ?, ?)
`

type CreateUserKeyParams struct {
	UserID       string `json:"user_id"`
	KekVersion   int64  `json:"kek_version"`
	EncryptedDek []byte `json:"encrypted_dek"`
	CreatedAt    int64  `json:"created_at"`
}

// User keys operations
func (q *Queries) CreateUserKey(ctx context.Context, arg CreateUserKeyParams) error {
	_, err := q.db.ExecContext(ctx, createUserKey,
		arg.UserID,
		arg.KekVersion,
		arg.EncryptedDek,
		arg.CreatedAt,
	)
	return err
}

const deleteExpiredMagicTokens = `-- name: DeleteExpiredMagicTokens :exec
DELETE FROM magic_tokens WHERE expires_at < ?
`

func (q *Queries) DeleteExpiredMagicTokens(ctx context.Context, expiresAt int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredMagicTokens, expiresAt)
	return err
}

const deleteExpiredMagicTokensNow = `-- name: DeleteExpiredMagicTokensNow :exec
DELETE FROM magic_tokens WHERE expires_at <= CAST(strftime('%s', 'now') AS INTEGER)
`

func (q *Queries) DeleteExpiredMagicTokensNow(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredMagicTokensNow)
	return err
}

const deleteExpiredOAuthCodes = `-- name: DeleteExpiredOAuthCodes :exec
DELETE FROM oauth_codes WHERE expires_at < ?
`

func (q *Queries) DeleteExpiredOAuthCodes(ctx context.Context, expiresAt int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredOAuthCodes, expiresAt)
	return err
}

const deleteExpiredOAuthTokens = `-- name: DeleteExpiredOAuthTokens :exec
DELETE FROM oauth_tokens WHERE expires_at < ?
`

func (q *Queries) DeleteExpiredOAuthTokens(ctx context.Context, expiresAt int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredOAuthTokens, expiresAt)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions WHERE expires_at < ?
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context, expiresAt int64) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSessions, expiresAt)
	return err
}

const deleteExpiredSessionsNow = `-- name: DeleteExpiredSessionsNow :exec
DELETE FROM sessions WHERE expires_at <= CAST(strftime('%s', 'now') AS INTEGER)
`

func (q *Queries) DeleteExpiredSessionsNow(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSessionsNow)
	return err
}

const deleteMagicToken = `-- name: DeleteMagicToken :exec
DELETE FROM magic_tokens WHERE token_hash = ?
`

func (q *Queries) DeleteMagicToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.ExecContext(ctx, deleteMagicToken, tokenHash)
	return err
}

const deleteMagicTokensByEmail = `-- name: DeleteMagicTokensByEmail :exec
DELETE FROM magic_tokens WHERE email = ?
`

func (q *Queries) DeleteMagicTokensByEmail(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteMagicTokensByEmail, email)
	return err
}

const deleteOAuthClient = `-- name: DeleteOAuthClient :exec
DELETE FROM oauth_clients WHERE client_id = ?
`

func (q *Queries) DeleteOAuthClient(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, deleteOAuthClient, clientID)
	return err
}

const deleteOAuthCode = `-- name: DeleteOAuthCode :exec
DELETE FROM oauth_codes WHERE code_hash = ?
`

func (q *Queries) DeleteOAuthCode(ctx context.Context, codeHash string) error {
	_, err := q.db.ExecContext(ctx, deleteOAuthCode, codeHash)
	return err
}

const deleteOAuthToken = `-- name: DeleteOAuthToken :exec
DELETE FROM oauth_tokens WHERE access_token_hash = ?
`

func (q *Queries) DeleteOAuthToken(ctx context.Context, accessTokenHash string) error {
	_, err := q.db.ExecContext(ctx, deleteOAuthToken, accessTokenHash)
	return err
}

const deleteOAuthTokensByClientID = `-- name: DeleteOAuthTokensByClientID :exec
DELETE FROM oauth_tokens WHERE client_id = ?
`

func (q *Queries) DeleteOAuthTokensByClientID(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, deleteOAuthTokensByClientID, clientID)
	return err
}

const deleteOAuthTokensByUserID = `-- name: DeleteOAuthTokensByUserID :exec
DELETE FROM oauth_tokens WHERE user_id = ?
`

func (q *Queries) DeleteOAuthTokensByUserID(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteOAuthTokensByUserID, userID)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE session_id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, sessionID)
	return err
}

const deleteSessionsByUserID = `-- name: DeleteSessionsByUserID :exec
DELETE FROM sessions WHERE user_id = ?
`

func (q *Queries) DeleteSessionsByUserID(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteSessionsByUserID, userID)
	return err
}

const deleteShortURL = `-- name: DeleteShortURL :exec
DELETE FROM short_urls WHERE short_id = ?
`

func (q *Queries) DeleteShortURL(ctx context.Context, shortID string) error {
	_, err := q.db.ExecContext(ctx, deleteShortURL, shortID)
	return err
}

const deleteShortURLByFullPath = `-- name: DeleteShortURLByFullPath :exec
DELETE FROM short_urls WHERE full_path = ?
`

func (q *Queries) DeleteShortURLByFullPath(ctx context.Context, fullPath string) error {
	_, err := q.db.ExecContext(ctx, deleteShortURLByFullPath, fullPath)
	return err
}

const deleteUserKey = `-- name: DeleteUserKey :exec
DELETE FROM user_keys WHERE user_id = ?
`

func (q *Queries) DeleteUserKey(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserKey, userID)
	return err
}

const getMagicToken = `-- name: GetMagicToken :one
SELECT token_hash, email, user_id, expires_at, created_at
FROM magic_tokens
WHERE token_hash = ?
`

func (q *Queries) GetMagicToken(ctx context.Context, tokenHash string) (MagicToken, error) {
	row := q.db.QueryRowContext(ctx, getMagicToken, tokenHash)
	var i MagicToken
	err := row.Scan(
		&i.TokenHash,
		&i.Email,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMagicTokensByEmail = `-- name: GetMagicTokensByEmail :many
SELECT token_hash, email, user_id, expires_at, created_at
FROM magic_tokens
WHERE email = ?
ORDER BY created_at DESC
`

func (q *Queries) GetMagicTokensByEmail(ctx context.Context, email string) ([]MagicToken, error) {
	rows, err := q.db.QueryContext(ctx, getMagicTokensByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MagicToken{}
	for rows.Next() {
		var i MagicToken
		if err := rows.Scan(
			&i.TokenHash,
			&i.Email,
			&i.UserID,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOAuthClient = `-- name: GetOAuthClient :one
SELECT client_id, client_secret_hash, client_name, redirect_uris, is_public, token_endpoint_auth_method, created_at
FROM oauth_clients
WHERE client_id = ?
`

func (q *Queries) GetOAuthClient(ctx context.Context, clientID string) (OauthClient, error) {
	row := q.db.QueryRowContext(ctx, getOAuthClient, clientID)
	var i OauthClient
	err := row.Scan(
		&i.ClientID,
		&i.ClientSecretHash,
		&i.ClientName,
		&i.RedirectUris,
		&i.IsPublic,
		&i.TokenEndpointAuthMethod,
		&i.CreatedAt,
	)
	return i, err
}

const getOAuthCode = `-- name: GetOAuthCode :one
SELECT code_hash, client_id, user_id, redirect_uri, scope, resource, code_challenge, code_challenge_method, expires_at, created_at
FROM oauth_codes
WHERE code_hash = ?
`

func (q *Queries) GetOAuthCode(ctx context.Context, codeHash string) (OauthCode, error) {
	row := q.db.QueryRowContext(ctx, getOAuthCode, codeHash)
	var i OauthCode
	err := row.Scan(
		&i.CodeHash,
		&i.ClientID,
		&i.UserID,
		&i.RedirectUri,
		&i.Scope,
		&i.Resource,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOAuthToken = `-- name: GetOAuthToken :one
SELECT access_token_hash, refresh_token_hash, client_id, user_id, scope, resource, expires_at, created_at
FROM oauth_tokens
WHERE access_token_hash = ?
`

func (q *Queries) GetOAuthToken(ctx context.Context, accessTokenHash string) (OauthToken, error) {
	row := q.db.QueryRowContext(ctx, getOAuthToken, accessTokenHash)
	var i OauthToken
	err := row.Scan(
		&i.AccessTokenHash,
		&i.RefreshTokenHash,
		&i.ClientID,
		&i.UserID,
		&i.Scope,
		&i.Resource,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOAuthTokenByRefresh = `-- name: GetOAuthTokenByRefresh :one
SELECT access_token_hash, refresh_token_hash, client_id, user_id, scope, resource, expires_at, created_at
FROM oauth_tokens
WHERE refresh_token_hash = ?
`

func (q *Queries) GetOAuthTokenByRefresh(ctx context.Context, refreshTokenHash sql.NullString) (OauthToken, error) {
	row := q.db.QueryRowContext(ctx, getOAuthTokenByRefresh, refreshTokenHash)
	var i OauthToken
	err := row.Scan(
		&i.AccessTokenHash,
		&i.RefreshTokenHash,
		&i.ClientID,
		&i.UserID,
		&i.Scope,
		&i.Resource,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOAuthTokensByUserClient = `-- name: GetOAuthTokensByUserClient :many
SELECT access_token_hash, refresh_token_hash, client_id, user_id, scope, resource, expires_at, created_at
FROM oauth_tokens
WHERE user_id = ? AND client_id = ?
ORDER BY created_at DESC
`

type GetOAuthTokensByUserClientParams struct {
	UserID   string `json:"user_id"`
	ClientID string `json:"client_id"`
}

func (q *Queries) GetOAuthTokensByUserClient(ctx context.Context, arg GetOAuthTokensByUserClientParams) ([]OauthToken, error) {
	rows, err := q.db.QueryContext(ctx, getOAuthTokensByUserClient, arg.UserID, arg.ClientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OauthToken{}
	for rows.Next() {
		var i OauthToken
		if err := rows.Scan(
			&i.AccessTokenHash,
			&i.RefreshTokenHash,
			&i.ClientID,
			&i.UserID,
			&i.Scope,
			&i.Resource,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT session_id, user_id, expires_at, created_at
FROM sessions
WHERE session_id = ?
`

func (q *Queries) GetSession(ctx context.Context, sessionID string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, sessionID)
	var i Session
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionsByUserID = `-- name: GetSessionsByUserID :many
SELECT session_id, user_id, expires_at, created_at
FROM sessions
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetSessionsByUserID(ctx context.Context, userID string) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShortURLByFullPath = `-- name: GetShortURLByFullPath :one
SELECT id, short_id, full_path, created_at
FROM short_urls
WHERE full_path = ?
`

func (q *Queries) GetShortURLByFullPath(ctx context.Context, fullPath string) (ShortUrl, error) {
	row := q.db.QueryRowContext(ctx, getShortURLByFullPath, fullPath)
	var i ShortUrl
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.FullPath,
		&i.CreatedAt,
	)
	return i, err
}

const getShortURLByShortID = `-- name: GetShortURLByShortID :one
SELECT id, short_id, full_path, created_at
FROM short_urls
WHERE short_id = ?
`

func (q *Queries) GetShortURLByShortID(ctx context.Context, shortID string) (ShortUrl, error) {
	row := q.db.QueryRowContext(ctx, getShortURLByShortID, shortID)
	var i ShortUrl
	err := row.Scan(
		&i.ID,
		&i.ShortID,
		&i.FullPath,
		&i.CreatedAt,
	)
	return i, err
}

const getUserKey = `-- name: GetUserKey :one
SELECT user_id, kek_version, encrypted_dek, created_at, rotated_at
FROM user_keys
WHERE user_id = ?
`

func (q *Queries) GetUserKey(ctx context.Context, userID string) (UserKey, error) {
	row := q.db.QueryRowContext(ctx, getUserKey, userID)
	var i UserKey
	err := row.Scan(
		&i.UserID,
		&i.KekVersion,
		&i.EncryptedDek,
		&i.CreatedAt,
		&i.RotatedAt,
	)
	return i, err
}

const getValidMagicToken = `-- name: GetValidMagicToken :one
SELECT token_hash, email, user_id, expires_at, created_at FROM magic_tokens WHERE token_hash = ? AND expires_at > CAST(strftime('%s', 'now') AS INTEGER)
`

func (q *Queries) GetValidMagicToken(ctx context.Context, tokenHash string) (MagicToken, error) {
	row := q.db.QueryRowContext(ctx, getValidMagicToken, tokenHash)
	var i MagicToken
	err := row.Scan(
		&i.TokenHash,
		&i.Email,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getValidOAuthCode = `-- name: GetValidOAuthCode :one
SELECT code_hash, client_id, user_id, redirect_uri, scope, resource, code_challenge, code_challenge_method, expires_at, created_at
FROM oauth_codes
WHERE code_hash = ? AND expires_at > CAST(strftime('%s', 'now') AS INTEGER)
`

func (q *Queries) GetValidOAuthCode(ctx context.Context, codeHash string) (OauthCode, error) {
	row := q.db.QueryRowContext(ctx, getValidOAuthCode, codeHash)
	var i OauthCode
	err := row.Scan(
		&i.CodeHash,
		&i.ClientID,
		&i.UserID,
		&i.RedirectUri,
		&i.Scope,
		&i.Resource,
		&i.CodeChallenge,
		&i.CodeChallengeMethod,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getValidSession = `-- name: GetValidSession :one
SELECT session_id, user_id, expires_at, created_at FROM sessions WHERE session_id = ? AND expires_at > CAST(strftime('%s', 'now') AS INTEGER)
`

func (q *Queries) GetValidSession(ctx context.Context, sessionID string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getValidSession, sessionID)
	var i Session
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const listOAuthClients = `-- name: ListOAuthClients :many
SELECT client_id, client_secret_hash, client_name, redirect_uris, is_public, token_endpoint_auth_method, created_at
FROM oauth_clients
ORDER BY created_at DESC
`

func (q *Queries) ListOAuthClients(ctx context.Context) ([]OauthClient, error) {
	rows, err := q.db.QueryContext(ctx, listOAuthClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OauthClient{}
	for rows.Next() {
		var i OauthClient
		if err := rows.Scan(
			&i.ClientID,
			&i.ClientSecretHash,
			&i.ClientName,
			&i.RedirectUris,
			&i.IsPublic,
			&i.TokenEndpointAuthMethod,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOAuthClient = `-- name: UpdateOAuthClient :exec
UPDATE oauth_clients
SET client_secret_hash = ?, client_name = ?, redirect_uris = ?
WHERE client_id = ?
`

type UpdateOAuthClientParams struct {
	ClientSecretHash sql.NullString `json:"client_secret_hash"`
	ClientName       sql.NullString `json:"client_name"`
	RedirectUris     string         `json:"redirect_uris"`
	ClientID         string         `json:"client_id"`
}

func (q *Queries) UpdateOAuthClient(ctx context.Context, arg UpdateOAuthClientParams) error {
	_, err := q.db.ExecContext(ctx, updateOAuthClient,
		arg.ClientSecretHash,
		arg.ClientName,
		arg.RedirectUris,
		arg.ClientID,
	)
	return err
}

const updateUserKey = `-- name: UpdateUserKey :exec
UPDATE user_keys
SET kek_version = ?, encrypted_dek = ?, rotated_at = ?
WHERE user_id = ?
`

type UpdateUserKeyParams struct {
	KekVersion   int64         `json:"kek_version"`
	EncryptedDek []byte        `json:"encrypted_dek"`
	RotatedAt    sql.NullInt64 `json:"rotated_at"`
	UserID       string        `json:"user_id"`
}

func (q *Queries) UpdateUserKey(ctx context.Context, arg UpdateUserKeyParams) error {
	_, err := q.db.ExecContext(ctx, updateUserKey,
		arg.KekVersion,
		arg.EncryptedDek,
		arg.RotatedAt,
		arg.UserID,
	)
	return err
}

const upsertMagicToken = `-- name: UpsertMagicToken :exec
INSERT INTO magic_tokens (token_hash, email, user_id, expires_at, created_at)
VALUES (?, ?, ?, ?, ?) ON CONFLICT(token_hash) DO UPDATE SET expires_at = excluded.expires_at
`

type UpsertMagicTokenParams struct {
	TokenHash string         `json:"token_hash"`
	Email     string         `json:"email"`
	UserID    sql.NullString `json:"user_id"`
	ExpiresAt int64          `json:"expires_at"`
	CreatedAt int64          `json:"created_at"`
}

func (q *Queries) UpsertMagicToken(ctx context.Context, arg UpsertMagicTokenParams) error {
	_, err := q.db.ExecContext(ctx, upsertMagicToken,
		arg.TokenHash,
		arg.Email,
		arg.UserID,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const upsertSession = `-- name: UpsertSession :exec
INSERT INTO sessions (session_id, user_id, expires_at, created_at)
VALUES (?, ?, ?, ?) ON CONFLICT(session_id) DO UPDATE SET expires_at = excluded.expires_at
`

type UpsertSessionParams struct {
	SessionID string `json:"session_id"`
	UserID    string `json:"user_id"`
	ExpiresAt int64  `json:"expires_at"`
	CreatedAt int64  `json:"created_at"`
}

func (q *Queries) UpsertSession(ctx context.Context, arg UpsertSessionParams) error {
	_, err := q.db.ExecContext(ctx, upsertSession,
		arg.SessionID,
		arg.UserID,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const upsertUserKey = `-- name: UpsertUserKey :exec
INSERT INTO user_keys (user_id, kek_version, encrypted_dek, created_at, rotated_at)
VALUES (?, ?, ?, ?, ?) ON CONFLICT(user_id) DO UPDATE SET
  kek_version = excluded.kek_version, encrypted_dek = excluded.encrypted_dek, rotated_at = excluded.rotated_at
`

type UpsertUserKeyParams struct {
	UserID       string        `json:"user_id"`
	KekVersion   int64         `json:"kek_version"`
	EncryptedDek []byte        `json:"encrypted_dek"`
	CreatedAt    int64         `json:"created_at"`
	RotatedAt    sql.NullInt64 `json:"rotated_at"`
}

func (q *Queries) UpsertUserKey(ctx context.Context, arg UpsertUserKeyParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserKey,
		arg.UserID,
		arg.KekVersion,
		arg.EncryptedDek,
		arg.CreatedAt,
		arg.RotatedAt,
	)
	return err
}
